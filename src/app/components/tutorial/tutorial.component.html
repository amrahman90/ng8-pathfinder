<div id="tutorial" [ngStyle]="{ display: showTutorial ? 'block' : 'none' }">
  <!-- Begin step 1 -->
  <div *ngIf="currentStepNumber == 1" id="tutorial-sub">
    <h3>Welcome to Pathfinding Visualizer!</h3>
    <h6>
      This short tutorial will walk you through all of the features of this
      application.
    </h6>
    <p>
      If you want to dive right in, feel free to press the "Skip Tutorial"
      button below. Otherwise, press "Next"!
    </p>
    <img id="mainTutorialImage" src="assets/c_icon.png" />
  </div>
  <!-- End step 1 -->

  <!-- Begin step 2 -->
  <div *ngIf="currentStepNumber == 2" id="tutorial-sub">
    <h3>What is a pathfinding algorithm?</h3>
    <h6>
      At its core, a pathfinding algorithm seeks to find the shortest path
      between two points. This application visualizes various pathfinding
      algorithms in action, and more!
    </h6>
    <p>
      All of the algorithms on this application are adapted for a 2D grid, where
      90 degree turns have a "cost" of 1 and movements from a node to another
      have a "cost" of 1.
    </p>
    <img id="mainTutorialImage" src="assets/path.png" />
  </div>
  <!-- End step 2 -->

  <!-- Begin step 3 -->
  <div *ngIf="currentStepNumber == 3" id="tutorial-sub">
    <h3>Picking an algorithm</h3>
    <h6>Choose an algorithm from the "Algorithms" drop-down menu.</h6>
    <p>
      Note that some algorithms are <i><b>unweighted</b></i
      >, while others are <i><b>weighted</b></i
      >. Unweighted algorithms do not take turns or weight nodes into account,
      whereas weighted ones do. Additionally, not all algorithms guarantee the
      shortest path.
    </p>
    <img id="secondTutorialImage" src="assets/algorithms.png" />
  </div>
  <!-- End step 3 -->

  <!-- Begin step 3 -->
  <div *ngIf="currentStepNumber == 4" id="tutorial-sub">
    <h3>Meet the algorithms</h3>
    <h6>Not all algorithms are created equal.</h6>
    <ul>
      <li>
        <b>Dijkstra's Algorithm</b> (weighted): the father of pathfinding
        algorithms; guarantees the shortest path
      </li>
      <li>
        <b>A* Search</b> (weighted): arguably the best pathfinding algorithm;
        uses heuristics to guarantee the shortest path much faster than
        Dijkstra's Algorithm
      </li>
      <li>
        <b>Greedy Best-first Search</b> (weighted): a faster, more
        heuristic-heavy version of A*; does not guarantee the shortest path
      </li>
      <li>
        <b>Swarm Algorithm</b> (weighted): a mixture of Dijkstra's Algorithm and
        A*; does not guarantee the shortest-path
      </li>
      <li>
        <b>Convergent Swarm Algorithm</b> (weighted): the faster, more
        heuristic-heavy version of Swarm; does not guarantee the shortest path
      </li>
      <li>
        <b>Bidirectional Swarm Algorithm</b> (weighted): Swarm from both sides;
        does not guarantee the shortest path
      </li>
      <li>
        <b>Breath-first Search</b> (unweighted): a great algorithm; guarantees
        the shortest path
      </li>
      <li>
        <b>Depth-first Search</b> (unweighted): a very bad algorithm for
        pathfinding; does not guarantee the shortest path
      </li>
    </ul>
  </div>
  <!-- End step 4 -->

  <!-- Begin step 5 -->
  <div *ngIf="currentStepNumber == 5" id="tutorial-sub">
    <h3>Adding walls and weights</h3>
    <h6>
      Click on the grid to add a wall. Click on the grid while pressing W to add
      a weight. Generate mazes and patterns from the "Mazes & Patterns"
      drop-down menu.
    </h6>
    <p>
      Walls are impenetrable, meaning that a path cannot cross through them.
      Weights, however, are not impassable. They are simply more "costly" to
      move through. In this application, moving through a weight node has a
      "cost" of 15.
    </p>
    <img id="secondTutorialImage" src="assets/walls.gif" />
  </div>
  <!-- End step 5 -->

  <!-- Begin step 6 -->
  <div *ngIf="currentStepNumber == 6" id="tutorial-sub">
    <h3>Adding a bomb</h3>
    <h6>Click the "Add Bomb" button.</h6>
    <p>
      Adding a bomb will change the course of the chosen algorithm. In other
      words, the algorithm will first look for the bomb (in an effort to diffuse
      it) and will then look for the target node. Note that the Bidirectional
      Swarm Algorithm does not support adding a bomb.
    </p>
    <img id="secondTutorialImage" src="assets/bomb.png" />
  </div>
  <!-- End step 6 -->

  <!-- Begin step 7 -->
  <div *ngIf="currentStepNumber == 7" id="tutorial-sub">
    <h3>Dragging nodes</h3>
    <h6>Click and drag the start, bomb, and target nodes to move them.</h6>
    <p>
      Note that you can drag nodes even after an algorithm has finished running.
      This will allow you to instantly see different paths.
    </p>
    <img src="assets/dragging.gif" />
  </div>
  <!-- End step 7 -->

  <!-- Begin step 8 -->
  <div *ngIf="currentStepNumber == 8" id="tutorial-sub">
    <h3>Visualizing and more</h3>
    <h6>
      Use the navbar buttons to visualize algorithms and to do other stuff!
    </h6>
    <p>
      You can clear the current path, clear walls and weights, clear the entire
      board, and adjust the visualization speed, all from the navbar. If you
      want to access this tutorial again, click on "Pathfinding Visualizer" in
      the top left corner of your screen.
    </p>
    <img id="secondTutorialImage" src="assets/navbar.png" />
  </div>
  <!-- End step 8 -->

  <!-- Begin step 9 -->
  <div *ngIf="currentStepNumber == 9" id="tutorial-sub">
    <h3>Enjoy!</h3>
    <h6>
      I hope you have just as much fun playing around with this visualization
      tool as I had building it!
    </h6>
    <p>
      If you want to see the source code for this application, check out my
      <a href="https://github.com/clementmihailescu/Pathfinding-Visualizer"
        >github</a
      >.
    </p>
  </div>
  <div id="tutorialCounter">{{ currentStepNumber }}/9</div>
  <!-- Begin step 9 -->

  <div class="d-none d-sm-block">
    <button
      id="nextButton"
      class="btn btn-default navbar-btn"
      type="button"
      (click)="nextStep()"
      [ngStyle]="{ display: !isFinish ? 'block' : 'none' }"
    >
      Next
    </button>
    <button
      id="finishButton"
      class="btn btn-default navbar-btn"
      type="button"
      [ngStyle]="{ display: isFinish ? 'block' : 'none' }"
      (click)="hideTutorial()"
    >
      Finish
    </button>
    <button
      id="previousButton"
      class="btn btn-default navbar-btn"
      type="button"
      (click)="previousStep()"
    >
      Previous
    </button>

    <button
      id="skipButton"
      class="btn btn-default navbar-btn"
      type="button"
      (click)="hideTutorial()"
    >
      Skip Tutorial
    </button>
  </div>
</div>
